{"componentChunkName":"component---src-templates-blog-post-js","path":"/compose-lifecycle/","result":{"data":{"site":{"siteMetadata":{"title":"양송이","author":"song2","lang":"ko"}},"markdownRemark":{"id":"b8e1fdc7-79cb-5b97-aaed-b1d67026c81c","excerpt":"사내 Admin에 Compose를 도입했다. 이전에 사이드 프로젝트에서 적용 해 본 경험이 있는지라 Compose로 UI를 구성하고, 상태와 데이터를 관리 하는 것은 시간은 걸리되 생각보다 그리 어렵지 않았다. 오히려 Compose…","html":"</br>\n<p>사내 Admin에 Compose를 도입했다. 이전에 사이드 프로젝트에서 적용 해 본 경험이 있는지라 Compose로 UI를 구성하고, 상태와 데이터를 관리 하는 것은 시간은 걸리되 생각보다 그리 어렵지 않았다. 오히려 Compose의 편의성을 몸소 체감하며 개발을 하는 중이다.</p>\n<p>그러나 예상과 다르게 자잘한 이슈들은 Compose의 핵심인 recomposition의 동작과정을 이해하지 못하는 데서 왔다.\nCompose의 생명주기는 매우 심플하다. 처음에는 이 간단한 lifecycle이 개발을 더 단순하고 편리하게 해 줄 것이라고 기대했지만, 개발을 하면 할수록 fragment와 activity의 라이프사이클에 익숙한 나는 생명주기에 맞춰 이벤트를 처리하는 방식과 리엑티브 패러다임의 선언적 UI의 데이터 업데이트 방식에 혼란이 찾아왔다.</p>\n<p>Compose에 대해 가볍게 훑어보고, 동작원리와 생명주기를 파악해 보려고 한다.\n이후 프로젝트를 진행하며 마주했던 이슈들을 토대로 Compose로 개발 할 때 고려하면 좋은 점을 정리 해 보았다.</p>\n<hr>\n<h2 id=\"-overview\" style=\"position:relative;\"><a href=\"#-overview\" aria-label=\" overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>| overview</h2>\n<ol>\n<li>Compose란?\n<ol>\n<li>Compose의 특징</li>\n<li>선언형 패러다임</li>\n</ol>\n</li>\n<li>Compose의 라이프사이클</li>\n<li>recomposition 관련 이슈 (2편에서)\n<ol>\n<li>Composable의 잦은 재호출</li>\n<li>생명주기에 따른 이벤트 처리</li>\n<li>paging 데이터 유지하기</li>\n</ol>\n</li>\n</ol>\n<hr>\n<h2 id=\"compose란\" style=\"position:relative;\"><a href=\"#compose%EB%9E%80\" aria-label=\"compose란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose란?</h2>\n<p>Android에서 UI 개발을 위해 제공하는 툴킷이다.\n반응형 프로그래밍 모델을 기반하여 동작하며, 이에 코틀린의 간결성과 손쉬움을 결합했다.</p>\n<h3 id=\"compose의-특징\" style=\"position:relative;\"><a href=\"#compose%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"compose의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose의 특징</h3>\n<p>Compose에는 다음과 같은 특징이 있다.</p>\n<ol>\n<li class=\"li-title\"><b>선언형</b></li>\n<p>우리는 이전 xml을 활용한 UI 개발에서 뷰의 계층을 줄이기 위해 Constraintlayout의 사용을 권장한다.</br>\n그러나 선언형 프로그래밍 패러다임은 다르다. 처음부터 모든 구조를 생성한 후, 변경사항이 있는 경우에만 뷰가 업데이트 된다. 컴포즈에서는 이를 <code class=\"language-text\">recomposition</code> 이라고 하는데, 이는 나중에 다뤄보도록 하자.</p>\n<li class=\"li-title\"><b>보일러 플레이팅 코드의 감소</b></li>\nActivity, Fragment와 XML를 하나의 View에서 관리가 가능해진다. 따라서 xml을 Activity, Fragment에 inflate하는 과정이 사라진다.</br>\n또한 MVVM 아키텍처일 경우 VM에서 상태를 쉽게 전달 받을 수 있다. 데이터를 binding 한 후, observe 하고 update 하는 코드가 필요 없어진다.</br>\n커스텀 뷰를 생성하는 경우, 이전에는 ui를 그리기 위한 xml 파일, 동작을 위한 kotlin 파일, 속성 설정을 위한 파일 등이 필요했지만, compose 의 경우 composable 에서 처리가능하다.</br>\n</br>\n<li class=\"li-title\"><b>재사용 가능한 UI</b></li>\n</br>\n<li class=\"li-title\"><b>동적인 UI 구성</b></li>\nxml이 아닌 kotlin으로 동작하기 때문에, if 문을 사용한 특정 UI 노출여부, 반복문, 리스트 등과 같은 동적 UI를 구성하는 것이 가능해진다. \n</ol>\n</br>\n<p>그러나 <strong>아쉬운점</strong>도 존재한다.</p>\n<ol>\n<li>Resource 관련 기능 제한</li>\n<li>지원 라이브러리의 제한</li>\n<li>러닝커브로 인한 생산성 저하</li>\n</ol>\n<h3 id=\"선언형-프로그래밍-과-명령형-프로그래밍\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%96%B8%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B3%BC-%EB%AA%85%EB%A0%B9%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"선언형 프로그래밍 과 명령형 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선언형 프로그래밍 과 명령형 프로그래밍</h3>\n<p>위에서 명령형/선언형 프로그래밍에 대한 개념이 등장하는데, 이해를 돕기 위해 내용을 조금 더 추가해 보겠다.\n안드로이드 UI를 작성하는데 있어서 명령형으로 구현하는 방식과 선언형으로 구현하는 방식에는 다음과 같은 차이가 있다.</p>\n<li class=\"li-title\"><b>명령형</b></li>\n각 위젯은 자체의 내부 상태를 유지하고 getter, setter 메소드를 노출한다.\n그리고 우리는 state를 직접 변경하며 UI를 업데이트 한다.\n</br>\n</br>\n<li class=\"li-title\"><b>선언형</b></li>\n각 위젯은 stateless 상태이며 getter, setter 메소드를 노출하지 않는다. composable 함수를 인수로 호출하며 UI 를 업데이트 한다.\n<p>상태가 변경되면 composable은 새 데이터와 함께 다시 호출한다. 이 과정을 recomposition(재구성) 이라고 한다.</p>\n<p>여기서 리컴포지션이라는 개념이 재등장하게 되는데, 이제 Compose의 생명주기를 공부하며 함께 알아보자.</p>\n<h2 id=\"compose-의-lifecycle\" style=\"position:relative;\"><a href=\"#compose-%EC%9D%98-lifecycle\" aria-label=\"compose 의 lifecycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compose 의 lifecycle</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b14ff640ef38417a4ced52f0f6b5c738/b54cd/compose-lifecycle.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABt0lEQVQoz3WRy2sTURTG86+50I0uNGIXbsSFClqXgtRSXaQWxIV1kYIvqNVd174iKqigiRhiOsFOU6M4yWReaZJ5tffO5CczkxLs44PDPedwvo/znZsbjUYcFAn6gyG6YWE6Dm3dwNnqp/34EE4SuV3yLtJq3FNbGh/LNb5UFT5/+4Gy8TubScjsx3+CyRuPc3sQce1xj5nlAXPPXWZXhsw9c5lZHjK95PDXktmm8cTNvg1TwTjLNVty4pZBvmBw8b7FlaLNhUWL0/MGR653UTWRzkXxIZb32m7bkqkFk3zBTMWuLjlMF23OLJgcv2mw0RaT84wRx3EmmBRCSBrqJrWGyla/h+1Cft5m6rbJqYLDsVmLkwWHs3csjt4w+GOB5/WpKuusrTcJgnByQyFl+pM/my0UdROt06betLm02OJVPeTpe52VDzpP3mqU1nwuF3XKjR56t4Oi/kp5mm7QMUykjMgJIXA9Hz8I8fyASG5Tbzqcu9titRLwqKTzsKTz4HWH1YrH+Xs6Xxs94ijE9YOUl/C7pk0URZnlvZARfFIEL8o+b77vpFGq7vCyEvCutk0oOBCJ5X9oO5DEfL8ziAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"compose-lifecycle-0\"\n        title=\"compose-lifecycle-0\"\n        src=\"/static/b14ff640ef38417a4ced52f0f6b5c738/fcda8/compose-lifecycle.png\"\n        srcset=\"/static/b14ff640ef38417a4ced52f0f6b5c738/12f09/compose-lifecycle.png 148w,\n/static/b14ff640ef38417a4ced52f0f6b5c738/e4a3f/compose-lifecycle.png 295w,\n/static/b14ff640ef38417a4ced52f0f6b5c738/fcda8/compose-lifecycle.png 590w,\n/static/b14ff640ef38417a4ced52f0f6b5c738/efc66/compose-lifecycle.png 885w,\n/static/b14ff640ef38417a4ced52f0f6b5c738/c83ae/compose-lifecycle.png 1180w,\n/static/b14ff640ef38417a4ced52f0f6b5c738/b54cd/compose-lifecycle.png 1662w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>글의 초입에서도 말했듯, Compose의 lifecycle은 아주 심플하다.</p>\n<p><code class=\"language-text\">Composable이 Composition 시작 -&gt; 0회 이상 recomposition -&gt; comosition 종료</code></p>\n<p>그 중, recomposition 이라는 keyword에 집중해보자. composable 내에서 데이터가 변경 된 경우, UI를 재구성 한다.\n이때, composable은 모든 UI를 업데이트 하는것이 아니라, 값이 변경된 경우에만 composable을 호출하여 업데이트를 진행한다.\n참고로 호출 지점은 컴포저블이 호출되고 있는 소스코드의 위치이다.</p>\n<p>공식문서에서는 recomposition을 다음과 같이 정의한다.</p>\n<ol>\n<li>값에 종속되지 않은 다른 함수는 recompositon 되지 않는다.</li>\n<li>값에 종속되는 함수와 람다만 재생성한다.</li>\n<li>비용이 많이 드는 작업을 구성 외부의 다른 스레드로 이동하고 mutableStateOf 또는 LiveData를 사용하여 Compose에 데이터를 전달할 수 있다.</li>\n</ol>\n<p>코드를 보면 조금 더 이해하기가 쉽다.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">LoginScreen</span><span class=\"token punctuation\">(</span>showError<span class=\"token operator\">:</span> Boolean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">LoginError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">LoginInput</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token annotation builtin\">@Composable</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">LoginInput</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>LoginScreen은 LoginError와 LoginInput이라는 두개의 컴포저블을 가지고 있다.\nLoginScreen의 매개변수인 showError의 값이 변경 될 경우, LoginInput는 유지 되고 LoginError만 recomposition이 진행된다.</p>\n<p>구조상 하위 컴포저블이 모두 바뀐다고 착각하기 쉬우니 유의하도록 하자.</p>\n<h2 id=\"recomposition-관련-이슈\" style=\"position:relative;\"><a href=\"#recomposition-%EA%B4%80%EB%A0%A8-%EC%9D%B4%EC%8A%88\" aria-label=\"recomposition 관련 이슈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>recomposition 관련 이슈</h2>\n<p>compose를 적용하고 있는 프로젝트는 Single Activity 위에 Screen을 띄우는 방식으로 동작했다.\n프로젝트를 진행하며 마주한 이슈는 다음과 같다.</p>\n<ol>\n<li>Composable의 잦은 재호출</li>\n<li>생명주기에 따른 이벤트 처리</li>\n<li>페이징 리스트 데이터의 유지</li>\n</ol>\n<h3 id=\"composable의-잦은-재호출\" style=\"position:relative;\"><a href=\"#composable%EC%9D%98-%EC%9E%A6%EC%9D%80-%EC%9E%AC%ED%98%B8%EC%B6%9C\" aria-label=\"composable의 잦은 재호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Composable의 잦은 재호출</h3>\n<p>👉🏻 <strong>화면 전환을 위해 파라미터로 전달되는 navigation</strong></p>\n<p>👉🏻 <strong>Scope의 Recomposition</strong></p>\n<h3 id=\"view의-생명주기에-따른-이벤트-처리\" style=\"position:relative;\"><a href=\"#view%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B2%98%EB%A6%AC\" aria-label=\"view의 생명주기에 따른 이벤트 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>View의 생명주기에 따른 이벤트 처리</h3>\n<p>👉🏻 <strong>activity/fragment의 라이프 사이클 활용하기</strong></p>\n<h3 id=\"리스트의-데이터-유지\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9C%A0%EC%A7%80\" aria-label=\"리스트의 데이터 유지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리스트의 데이터 유지</h3>\n<p>👉🏻 <strong>페이징 데이터의 유자</strong></p>\n<p>해당 목차는 다음 포스팅에 이어서 작성해 보도록 하겠다.</p>\n<hr>\n<p>사실 프로젝트를 진행한 이슈들과 해결책까지 하나의 게시글에 작성하고 싶었지만, 글이 너무 길어 가독성이 떨어지는 이슈로 불가피하게 1,2편으로 나누어 연재하게 되었다.\n개요만 남겨뒀는데, 아마 2편이 올라오면 해당 목차는 지워질 듯 하다.\n여하튼 2편의 글도 거의다 완성이 된 상태라 금방 업데이트 될 듯 하다.</p>","timeToRead":4,"frontmatter":{"title":"compose의 생명주기(Recomposition) 이해하기","date":"April 10, 2022","description":"compose 이해하기, compose의 생명주기, recomposition","tags":["compose","lifecycle","recomposition"],"disqus":true},"fields":{"langKey":"ko"}}},"pageContext":{"slug":"/compose-lifecycle/","previous":null,"next":{"fields":{"slug":"/image-loader/","langKey":"ko","directoryName":"blog"},"frontmatter":{"date":"April 03, 2022","title":"라이브러리 없이 이미지 로드 구현하기","tags":["ImageLoader","Bitmap","BitmapFactory","Cache","LRU"]}},"previousInSameTag":null,"nextInSameTag":null,"translationsLink":[]}},"staticQueryHashes":["1522010811","1558996917","1615650028","3765107650"]}